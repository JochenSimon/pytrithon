module (0,0):
  from random import shuffle
  from poker import rank
var players (4,3);
python (2,3):
  reads: :args
  try:
    startchips = int(args[0])
  except:
    startchips = 1000
  playerlist = PlayerList([Player(name, aid, startchips, 0, False, False, Hand([])) for name,aid in players])
  takes: players:65
  gives: playerlist:players; 32
pool 16 (6,7);
out (8,7): poker.ante
  takes: aid,chips,hand,pot:16
ontology 27 (-5,0):
  concept Suite: pass
  concept Diamonds(Suite):
    def __str__(self): return 'D'
  concept Hearts(Suite):
    def __str__(self): return 'H'
  concept Clubs(Suite):
    def __str__(self): return 'C'
  concept Spades(Suite):
    def __str__(self): return 'S'
  concept Card:
    slot number: int
    slot suite: Suite
    def __str__(self):
      numberstr = 'A' if self.number == 1 else 'J' if \
          self.number == 11 else 'Q' if self.number == 12 else \
          'K' if self.number == 13 else str(self.number)
      return numberstr + 'o' + self.suite.__str__()
  concept Hand:
    slot cards: [Card]
    def __len__(self):
      return len(self.cards)
    def __iter__(self):
      for card in self.cards:
        yield card
    def __setitem__(self, key, value):
      self.cards[key] = value
    def append(self, card):
      self.cards.append(card)
    def __str__(self):
      return " ".join(str(c) for c in self.cards)
    def rank(self):
      return rank(self.cards)
  concept Deck:
    slot cards: [Card]
    def pop(self, index=None):
      if index is None:
        return self.cards.pop()
      return self.cards.pop(index)
    @staticmethod
    def shuffle():
      cards = [Card(num, suite()) for suite in [Diamonds, Hearts, Clubs, Spades] for num in range(1,14)]
      shuffle(cards)
      return Deck(cards)
  concept Player:
    slot name: str
    slot aid: str
    slot chips: int
    slot bet: int
    slot allin: bool
    slot folded: bool
    slot hand: Hand
  concept PlayerList:
    slot players: [Player]
    def __len__(self):
      return len(self.players)
    def __getitem__(self, key):
      if isinstance(key, int):
        return self.players[key]
      else:
        for player in self.players:
          if player.aid == key:
            return player
    def __iter__(self):
      for player in self.players:
        yield player
    def append(self, player):
      self.players.append(player)
    def maxbet(self):
      return max(player.bet for player in self.players)
    def active(self):
      return len([p for p in self.players if not p.folded])
  concept GameState:
    slot ante: int
    slot curplay: int
    slot lastraise: int
    slot pot: int
    slot swapsleft: int
var gs (4,0): GameState(0, 0, 0, 0, True)
out (5,7): poker.log
  takes: aids,line:30
var 30 (4,7);
var deck (10,0): Deck([])
flow 32 (2,8);
python (4,8):
  reads: :args
  writes: :players; :deck; :gs
  try:
    gs.ante += int(args[1])
  except:
    gs.ante += 5
  for player in players:
    player.chips -= gs.ante
    player.bet = 0
    player.allin = False
    player.folded = False
    player.hand = Hand([])
  gs.pot += gs.ante * len(players)
  gs.lastraise = gs.curplay
  gs.swapsleft = len(players)
  deck = Deck.shuffle()
  for _ in range(5):
    for player in players:
      player.hand.append(deck.pop(0))
  data = [(p.aid,p.chips,p.hand,gs.pot) for p in players]
  agents = [p.aid for p in players]
  log = "Ante with {} chips paid".format(gs.ante)
  takes: 32
  gives: *data:16; agents,log:30; 34
flow 34 (6,8);
python (8,8):
  writes: :players; :gs
  player = players[gs.curplay%len(players)]
  aid = player.aid
  can = True
  pot = gs.pot
  range = players.maxbet(), player.chips
  takes: 34
  gives: aid,can,pot,range:36
var 36 (10,7);
out (10,6): poker.canbet
  takes: aid,can,pot,range:36
in (10,8): poker.bet
  gives: sender,bet:39
var 39 (10,10);
python (8,10):
  writes: :players; :gs
  player = players[sender]
  if bet == -1:
    player.folded = True
    log = "{} folded".format(player.name)
  elif bet > players.maxbet():
    gs.lastraise = gs.curplay
    log = "{} raised to {} chips".format(player.name, bet)
  else:
    log = "{} called {} chips".format(player.name, bet)
  agents = [p.aid for p in players]
  if not player.folded:
    more = bet - player.bet
    player.bet = bet
    player.chips -= more
    gs.pot += more
  gs.curplay += 1
  while players[gs.curplay%len(players)].folded:
    gs.curplay += 1
  if players.active() == 1:
    gs.swapsleft = 0
    finalbet = ()
  elif gs.lastraise+len(players) <= gs.curplay:
    finalbet = ()
  else:
    nextbet = ()
  takes: sender,bet:39
  gives: nextbet:34; agents,log:42; finalbet:55
flow 41 (10,15);
var 42 (8,9);
out =1 (9,9): poker.log
  takes: aids,line:42
python (7,15):
  writes: :players; :gs
  aid = players[gs.curplay%len(players)].aid
  can = True
  pot = gs.pot
  takes: 41
  gives: aid,can,pot:45
var 45 (5,15);
out (3,15): poker.canswap
  takes: aid,can,pot:45
in (6,14): poker.swap
  gives: swap,sender:48
var 48 (4,14);
python (2,14):
  writes: :players; :deck; :gs
  number = sum(1 if s else 0 for s in swap)
  cards = [deck.pop(0) for _ in range(number)]
  deal = list(cards)
  for i,s in enumerate(swap):
    if s:
      players[sender].hand[i] = deal.pop(0)
  agents = [p.aid for p in players]
  log = "{} swapped {} cards".format(players[sender].name, number)
  gs.curplay += 1
  gs.lastraise = gs.curplay
  gs.swapsleft -= 1
  while players[gs.curplay%len(players)].folded:
    gs.curplay += 1
    if gs.swapsleft:
      gs.swapsleft -= 1
  if not gs.swapsleft:
    finalswap = ()
  else:
    nextswap = ()
  takes: swap,sender:48
  gives: sender,cards,swap:50; agents,log:52; finalswap:34; nextswap:41
var 50 (0,14);
out (-2,14): poker.deal
  takes: aid,cards,swap:50
var 52 (2,13);
out (4,13): poker.log
  takes: aids,line:52
python (10,12):
  writes: :gs
  if not gs.swapsleft:
    roundover = ()
  else:
    toswap = ()
  takes: 55
  gives: toswap:41; roundover:56
flow 55 (10,11);
flow 56 (-2,12);
python (-2,8):
  writes: :players; :gs
  ranked = sorted([(p,p.hand.rank()) for p in players if not p.folded], key=lambda x: -x[1])
  winner = ranked[0][0]
  winner.chips += gs.pot
  agents = [p.aid for p in players]
  if players.active() == 1:
    log = "{} wins as everyone else folded".format(winner.name)
  else:
    log = "{} wins {} chips with the hand {}".format(winner.name, gs.pot, winner.hand)
    for p,r in ranked[1:]:
      log += " over {} with the hand {}".format(p.name, p.hand)
  gs.pot = 0
  takes: 56
  gives: agents,log:58; 32
var 58 (0,9);
out =1 (1,9): poker.log
  takes: aids,line:58
self (7,0);
know args (2,0);
frag (-3,3):
  lobby
  domain: poker
  gives: players:65
var 65 (0,3);
comment (5.4,1.3):
  This agent is not finished. It is missing the handling of
  players who cannot afford the ante and thus should be skipped.
  
  In order to use this Agent, after running it, start multiple
  "poker" Agents which then connect to the Lobby in order to
  trigger the starting of a game.
